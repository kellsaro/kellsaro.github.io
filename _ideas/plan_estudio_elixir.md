


# Plan de Estudio: Elixir y su Ecosistema

## Reglas importantes:
- Siempre introducir las mejores prácticas
- Siempre poner ejercicios teóricos y al menos 10 ejercicios prácticos sobre los temas tratados en la lección.
- Siempre las respuestas estarán al final
- Siempre se debe incluir una sección de referencias, con enlaces relevantes.
- Las lecciones deben ser simples, directas y legibles. Los ejemplos deben ser reales.

---

## 🧠 Fundamentos del Lenguaje Elixir

1. Introducción a Elixir y la BEAM
2. Tipos de datos básicos
3. Pattern Matching
4. Funciones y módulos
5. Recursión y tail recursion
6. Pipes (`|>`) y composición
7. Inmutabilidad y funciones puras
8. Guard clauses y control de flujo (`cond`, `case`, `with`, `if`)

---

## 🔄 Concurrencia y Procesos

9. Procesos (`spawn`, `send`, `receive`)
10. Supervisores y árboles de supervisión
11. Tasks y agentes
12. GenServer
13. OTP (Open Telecom Platform)

---

## 🧱 Ecosistema Base

14. Mix
15. IEx
16. Documentación (`@moduledoc`, `@doc`, ExDoc)

---

## 💾 Persistencia con Ecto

17. Instalación y configuración
18. Esquemas y migraciones
19. CRUD con `Repo`
20. Relaciones
21. Consultas con Ecto.Query
22. Changesets y validaciones
23. Ecto.Multi y transacciones

---

## 🌐 Desarrollo Web con Phoenix

24. Estructura del proyecto Phoenix
25. Rutas, controladores y vistas
26. Templates y componentes
27. Contextos
28. Formularios y cambiosets
29. Canales y WebSockets
30. Phoenix LiveView
31. Seguridad (CSRF, autenticación)

---

## ⚙️ Testing y buenas prácticas

32. ExUnit y doctests
33. Mocks y testing de concurrencia
34. Cobertura de pruebas

---

## 🚀 Ash Framework

35. Filosofía declarativa
36. Recursos (`Ash.Resource`)
37. APIs (`Ash.Api`)
38. Authorization y policies
39. Actions y relaciones
40. Integraciones con JSON:API y GraphQL

---

## 🌍 Producción y DevOps

41. Configuración y manejo de secrets
42. Releases (`mix release`)
43. Telemetry y métricas
44. Logging estructurado
45. Despliegue (Fly.io, Gigalixir, Docker)

---

## 🧠 Avanzado / Mastery

46. Metaprogramación (`quote`, `unquote`)
47. DSLs en Elixir
48. NIFs y C bindings
49. Optimización de rendimiento
50. Arquitecturas distribuidas con Elixir
